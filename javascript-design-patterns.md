### Creational Patterns (Object Creation)  
These patterns focus on object instantiation while maintaining flexibility and efficiency.  

- **Abstract Factory**: Creates families of related objects without specifying their concrete classes.  
- **Builder**: Constructs complex objects step-by-step for better readability and flexibility.  
- **Factory Method**: Defines an interface for object creation, allowing subclasses to determine the actual implementation.  
- **Prototype**: Creates new objects by copying an existing instance (useful for expensive object creation).  
- **Singleton**: Ensures only one instance of a class exists globally.  

### Structural Patterns (Class & Object Composition)  
These patterns simplify the design by organizing object relationships efficiently.  

- **Adapter (Composition & Inheritance)** → Converts one interface to another to enable compatibility.  
- **Bridge**: Decouples abstraction from implementation, allowing independent modifications.  
- **Composite**: Treats individual objects and groups of objects uniformly (tree structure).  
- **Decorator**: Dynamically adds new behavior to objects without altering existing code.  
- **Facade**: Provides a simple interface for complex subsystems.  
- **Flyweight**: Reduces memory usage by sharing common object instances.  
- **Proxy**: Controls access to an object, often used for security or performance optimizations.  

### Behavioral Patterns (Object Interaction)  
These patterns focus on communication between objects and define workflows.  

- **Chain of Responsibility**: Passes a request along a chain of handlers until one handles it.  
- **Command**: Encapsulates requests as objects, enabling undo/redo functionality.  
- **Interpreter**: Defines a language grammar and an interpreter to process expressions.  
- **Iterator**: Provides a way to sequentially access elements without exposing the underlying structure.  
- **Mediator**: Centralizes communication between objects to reduce dependencies.  
- **Memento**: Captures an object’s state to restore it later (useful for undo mechanisms).  
- **Observer**: Establishes a one-to-many dependency where observers get notified of state changes.  
- **State**: Allows an object to change its behavior when its state changes.  
- **Strategy**: Defines interchangeable algorithms that can be selected dynamically.  
- **Template Method**: Defines a skeleton for an algorithm, allowing subclasses to modify specific steps.  
- **Visitor**: Adds new operations to an object structure without modifying its classes.  
